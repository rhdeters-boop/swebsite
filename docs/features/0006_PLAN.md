SECTIONS

Testing philosophy and scope

Test folder layout, naming conventions, coverage thresholds

Jest configuration (root + backend), ESM variant, tsconfig.testing

Test infrastructure: global setup/teardown, docker-compose alternative, helpers

Concrete example source and tests (unit, service, middleware, API, snapshot, contract)

ORM adapters (Sequelize) and how to swap

In-memory DB option with SQLite for fast integration runs

NPM scripts

GitHub Actions CI workflow

Troubleshooting notes

README slice: local runs, integration modes, debugging

Testing philosophy and scope

Unit tests
What: Pure functions and tight units (lib/utils, validators, data mappers).
How: Isolate from I/O; mock everything external (DB, HTTP).
Why: Fast feedback, deterministic, pinpoint failures.
Integration tests (HTTP/API)
What: App wiring end-to-end in-memory (Express app via supertest), including routing, middleware, validation, and serialization.
Modes:
Default fast mode: Use in-memory DB approach (SQLite) or stub repositories to avoid network.
True infra mode: Use Testcontainers to boot Postgres/MySQL/Mongo, run migrations, and seed deterministic data.
Contract and snapshot tests
Contract: Validate third-party API schemas with lightweight schema (zod) or Pact. Mock real HTTP using nock (or MSW for Node).
Snapshot: Use sparingly for stable response shapes; redact timestamps/ids.
Coverage thresholds and exclusions

Target thresholds: statements 85%, branches 80%, functions 85%, lines 85%.
Exclude from coverage: configuration files, migrations/seeders/generated artifacts, test helpers, scripts, logger internals, server bootstrap entry that only calls listen().
Test folder layout and naming conventions
Collocated tests for units/services/middleware:
Example: backend/utils/__tests__/slug.test.ts
Central tests for API/contract/integration env:
Example: backend/tests/api/app.e2e.test.ts
Example: backend/tests/contract/third-party.contract.test.ts
File suffix: *.test.ts
Use Arrange-Act-Assert, stable faker seeds, precise assertions.
Jest configuration (root + backend), ESM variant, tsconfig.testing
Root projects config (monorepo-friendly; works even if single package)

File: jest.config.js
/* Root-level Jest config using projects. */

module.exports = {
  projects: [
    '<rootDir>/backend',
  ],
  watchPlugins: [
    'jest-watch-typeahead/filename',
    'jest-watch-typeahead/testname',
  ],
};

js


Backend Jest config (CommonJS default)

File: backend/jest.config.js
/* Backend Jest config (CommonJS). Works with TypeScript via ts-jest. */

const isCI = !!process.env.CI;
const useContainers = process.env.JEST_INTEGRATION_MODE === 'testcontainers';

module.exports = {
  displayName: 'backend',
  testEnvironment: 'node',
  preset: 'ts-jest',
  rootDir: '.',
  roots: ['<rootDir>'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  testMatch: ['**/?(*.)+(test).[tj]s'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/../$1',
  },
  transform: {
    '^.+\\.(ts|js)$': 'ts-jest',
  },
  globals: {
    'ts-jest': {
      tsconfig: '<rootDir>/tsconfig.testing.json',
      isolatedModules: true,
      diagnostics: true,
      useESM: false,
    },
  },
  setupFiles: [
    'dotenv/config',
  ],
  setupFilesAfterEnv: [
    '<rootDir>/jest.setup.ts',
  ],
  globalSetup: useContainers ? '<rootDir>/test/env/global-setup.ts' : undefined,
  globalTeardown: useContainers ? '<rootDir>/test/env/global-teardown.ts' : undefined,
  testTimeout: useContainers ? 60000 : 20000,
  collectCoverage: isCI || !!process.env.COVERAGE,
  collectCoverageFrom: [
    '<rootDir>/**/*.{ts,js}',
    '!<rootDir>/**/*.d.ts',
    '!<rootDir>/**/__tests__/**',
    '!<rootDir>/**/test/**',
    '!<rootDir>/**/tests/**',
    '!<rootDir>/**/scripts/**',
    '!<rootDir>/**/migrations/**',
    '!<rootDir>/**/seeders/**',
    '!<rootDir>/**/config/**',
    '!<rootDir>/**/models/index.*',
    '!<rootDir>/jest.*',
    '!<rootDir>/server.js',
  ],
  coverageDirectory: '<rootDir>/coverage',
  coverageReporters: ['json', 'lcov', 'text', 'clover'],
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/coverage/',
    '/test/',
    '/tests/',
    '/scripts/',
    '/migrations/',
    '/seeders/',
    '/config/',
    'server.js',
    '\\.d\\.ts$',
  ],
  coverageThreshold: {
    global: {
      statements: 85,
      branches: 80,
      functions: 85,
      lines: 85,
    },
  },
  testPathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/coverage/',
    '/test/helpers/',
  ],
  reporters: isCI
    ? [
        'default',
        ['jest-junit', { outputDirectory: '<rootDir>/reports', outputName: 'junit.xml' }],
      ]
    : ['default'],
  watchPlugins: [
    'jest-watch-typeahead/filename',
    'jest-watch-typeahead/testname',
  ],
};

js



Backend ESM variant (optional)

File: backend/jest.config.esm.js
/* Backend Jest config for ESM with ts-jest useESM: true. */

const isCI = !!process.env.CI;
const useContainers = process.env.JEST_INTEGRATION_MODE === 'testcontainers';

export default {
  displayName: 'backend-esm',
  testEnvironment: 'node',
  preset: 'ts-jest/presets/default-esm',
  rootDir: '.',
  extensionsToTreatAsEsm: ['.ts'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  testMatch: ['**/?(*.)+(test).[tj]s'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/../$1',
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  transform: {
    '^.+\\.(ts|js)$': [
      'ts-jest',
      {
        useESM: true,
        tsconfig: '<rootDir>/tsconfig.testing.json',
        isolatedModules: true,
        diagnostics: true,
      },
    ],
  },
  setupFiles: ['dotenv/config'],
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  globalSetup: useContainers ? '<rootDir>/test/env/global-setup.ts' : undefined,
  globalTeardown: useContainers ? '<rootDir>/test/env/global-teardown.ts' : undefined,
  testTimeout: useContainers ? 60000 : 20000,
  collectCoverage: isCI || !!process.env.COVERAGE,
  collectCoverageFrom: [
    '<rootDir>/**/*.{ts,js}',
    '!<rootDir>/**/*.d.ts',
    '!<rootDir>/**/__tests__/**',
    '!<rootDir>/**/test/**',
    '!<rootDir>/**/tests/**',
    '!<rootDir>/**/scripts/**',
    '!<rootDir>/**/migrations/**',
    '!<rootDir>/**/seeders/**',
    '!<rootDir>/**/config/**',
    '!<rootDir>/**/models/index.*',
    '!<rootDir>/jest.*',
    '!<rootDir>/server.js',
  ],
  coverageDirectory: '<rootDir>/coverage',
  coverageReporters: ['json', 'lcov', 'text', 'clover'],
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/coverage/',
    '/test/',
    '/tests/',
    '/scripts/',
    '/migrations/',
    '/seeders/',
    '/config/',
    'server.js',
    '\\.d\\.ts$',
  ],
  coverageThreshold: {
    global: {
      statements: 85,
      branches: 80,
      functions: 85,
      lines: 85,
    },
  },
  testPathIgnorePatterns: [
    '/node_modules/',
    '/dist/',
    '/coverage/',
    '/test/helpers/',
  ],
  reporters: isCI
    ? [
        'default',
        ['jest-junit', { outputDirectory: '<rootDir>/reports', outputName: 'junit.xml' }],
      ]
    : ['default'],
  watchPlugins: [
    'jest-watch-typeahead/filename',
    'jest-watch-typeahead/testname',
  ],
};

js



Jest environment setup

File: backend/jest.setup.ts
/* Jest per-test-file setup for the backend. */
import { TextEncoder, TextDecoder } from 'util';
import nock from 'nock';

// Polyfills for some libs on Node
(global as any).TextEncoder = (global as any).TextEncoder || TextEncoder;
(global as any).TextDecoder = (global as any).TextDecoder || TextDecoder;

afterEach(() => {
  nock.cleanAll();
  nock.enableNetConnect(false); // Avoid unmocked network calls by default
});

beforeAll(() => {
  nock.disableNetConnect();
});

afterAll(() => {
  nock.restore();
});

ts



TypeScript config for Jest

File: backend/tsconfig.testing.json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "target": "ES2021",
    "module": "CommonJS",
    "esModuleInterop": true,
    "allowJs": true,
    "strict": true,
    "skipLibCheck": true,
    "baseUrl": "..",
    "paths": {
      "@/*": ["*"]
    },
    "types": ["node", "jest"]
  },
  "include": [
    "./**/*.ts",
    "../**/*.ts",
    "../**/*.d.ts"
  ],
  "exclude": [
    "**/dist/**",
    "**/coverage/**",
    "**/node_modules/**"
  ]
}

json



Note: If you do not have a tsconfig.json at the repository root, change "extends" to "./tsconfig.json" and ensure a minimal tsconfig exists in backend/.

Adapting to your current backend/server.js

Export your Express app from server.js and only listen when run directly. Alternatively, create a separate app builder (see backend/app.ts below) for tests to import without opening a port.
Test infrastructure: global setup/teardown, docker-compose alternative, helpers
Testcontainers global setup/teardown (Postgres example)

Files:
backend/test/env/global-setup.ts
backend/test/env/global-teardown.ts
/* backend/test/env/global-setup.ts */
import { Client } from 'pg';
import { GenericContainer, StartedTestContainer, Wait } from 'testcontainers';

type GlobalState = {
  container?: StartedTestContainer;
  pgUrl?: string;
};

async function runMigrationsAndSeed(pgUrl: string) {
  const client = new Client({ connectionString: pgUrl });
  await client.connect();
  try {
    await client.query(`
      create table if not exists users (
        id serial primary key,
        email text unique not null,
        password_hash text not null,
        created_at timestamptz default now()
      );
    `);
    await client.query(`
      insert into users (email, password_hash)
      values ('seeded@example.com', 'hash_seeded')
      on conflict (email) do nothing;
    `);
  } finally {
    await client.end();
  }
}

export default async function globalSetup() {
  const container = await new GenericContainer('postgres:16-alpine')
    .withEnv('POSTGRES_PASSWORD', 'postgres')
    .withEnv('POSTGRES_DB', 'testdb')
    .withExposedPorts(5432)
    .withWaitStrategy(Wait.forLogMessage('database system is ready to accept connections'))
    .start();

  const mappedPort = container.getMappedPort(5432);
  const host = container.getHost();
  const pgUrl = `postgres://postgres:postgres@${host}:${mappedPort}/testdb`;

  process.env.DB_HOST = host;
  process.env.DB_PORT = String(mappedPort);
  process.env.DB_NAME = 'testdb';
  process.env.DB_USER = 'postgres';
  process.env.DB_PASSWORD = 'postgres';
  process.env.DATABASE_URL = pgUrl;

  await runMigrationsAndSeed(pgUrl);

  (global as any).__TESTCONTAINERS_STATE__ = { container, pgUrl };
}

/* backend/test/env/global-teardown.ts */
import type { StartedTestContainer } from 'testcontainers';

export default async function globalTeardown() {
  const state = ((global as any).__TESTCONTAINERS_STATE__) as {
    container?: StartedTestContainer;
    pgUrl?: string;
  };

  if (state?.container) {
    await state.container.stop({ timeout: 10000 });
  }
}

ts



Alternative docker-compose for local/CI services

File: backend/test/env/docker-compose.test.yml
version: '3.9'
services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: testdb
    ports:
      - '5433:5432'
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres -d testdb']
      interval: 3s
      timeout: 3s
      retries: 10

yaml


Shared HTTP mocking helper and random data

Files:
backend/tests/helpers/httpMock.ts
backend/tests/helpers/random.ts
/* backend/tests/helpers/httpMock.ts */
import nock from 'nock';

export function allowNetConnectTo(hostPattern: RegExp | string) {
  nock.enableNetConnect(hostPattern);
}

export function mockJson(
  baseUrl: string,
  path: string,
  method: 'get' | 'post' | 'put' | 'patch' | 'delete' = 'get',
  status = 200,
  body: unknown = {},
  headers: Record<string, string> = { 'Content-Type': 'application/json' }
) {
  return nock(baseUrl)[method](path).reply(status, body, headers);
}

export function resetHttpMocks() {
  nock.cleanAll();
}

/* backend/tests/helpers/random.ts */
import { Faker, en } from '@faker-js/faker';

export function makeFaker(seed: number) {
  const faker = new Faker({ locale: [en] });
  faker.seed(seed);
  return faker;
}

ts



Concrete example source and tests (unit, service, middleware, API, snapshot, contract)
Pure unit util

Files:
backend/utils/slug.ts
backend/utils/__tests__/slug.test.ts
/* backend/utils/slug.ts */
export function toSlug(input: string): string {
  return String(input)
    .trim()
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)+/g, '');
}

/* backend/utils/__tests__/slug.test.ts */
import { toSlug } from '@/backend/utils/slug';

describe('toSlug (unit)', () => {
  test('trims, lowercases, removes diacritics, and collapses separators', () => {
    const input = '  HÃ©llo,  World!!  ';
    const out = toSlug(input);
    expect(out).toBe('hello-world');
  });

  test('returns empty string for only symbols', () => {
    expect(toSlug('---___***')).toBe('');
  });
});

ts



Service-layer with repository mock (Sequelize-friendly interface)

Files:
backend/services/user.service.ts
backend/services/__tests__/user.service.test.ts
/* backend/services/user.service.ts */
import bcrypt from 'bcryptjs';

export interface User {
  id: number;
  email: string;
  password_hash: string;
}

export interface UserRepository {
  findByEmail(email: string): Promise<User | null>;
  create(data: { email: string; password_hash: string }): Promise<User>;
}

export class UserService {
  constructor(private readonly repo: UserRepository) {}

  async register(email: string, password: string) {
    if (!email || !password) {
      throw new Error('Invalid input');
    }
    const existing = await this.repo.findByEmail(email);
    if (existing) {
      throw new Error('Email already in use');
    }
    const password_hash = await bcrypt.hash(password, 10);
    return this.repo.create({ email, password_hash });
  }

  async authenticate(email: string, password: string) {
    const user = await this.repo.findByEmail(email);
    if (!user) return null;
    const ok = await bcrypt.compare(password, user.password_hash);
    return ok ? user : null;
  }
}

/* backend/services/__tests__/user.service.test.ts */
import { UserService, UserRepository, User } from '@/backend/services/user.service';

describe('UserService (service unit with mocked repo)', () => {
  const repo: jest.Mocked<UserRepository> = {
    findByEmail: jest.fn(),
    create: jest.fn(),
  };

  beforeEach(() => jest.resetAllMocks());

  test('register: creates new user when email unused', async () => {
    repo.findByEmail.mockResolvedValue(null);
    repo.create.mockResolvedValue({ id: 1, email: 'new@example.com', password_hash: 'hash' } as User);

    const svc = new UserService(repo);
    const created = await svc.register('new@example.com', 'P@ssw0rd!');
    expect(created.id).toBe(1);
    expect(repo.findByEmail).toHaveBeenCalledWith('new@example.com');
    expect(repo.create).toHaveBeenCalledWith(expect.objectContaining({ email: 'new@example.com' }));
  });

  test('register: rejects duplicate email', async () => {
    repo.findByEmail.mockResolvedValue({ id: 1, email: 'dup@example.com', password_hash: 'h' } as User);
    const svc = new UserService(repo);
    await expect(svc.register('dup@example.com', 'x')).rejects.toThrow('Email already in use');
  });

  test('authenticate: returns user on valid password', async () => {
    const user = { id: 42, email: 'ok@example.com', password_hash: '$2a$10$somesaltedhash' } as User;
    repo.findByEmail.mockResolvedValue(user);

    const cmp = jest.spyOn(require('bcryptjs'), 'compare').mockResolvedValue(true);
    const svc = new UserService(repo);
    const u = await svc.authenticate('ok@example.com', 'correct');
    expect(u?.id).toBe(42);
    cmp.mockRestore();
  });
});

ts



Auth middleware

Files:
backend/middleware/auth.ts
backend/middleware/__tests__/auth.test.ts
/* backend/middleware/auth.ts */
import jwt from 'jsonwebtoken';
import type { Request, Response, NextFunction } from 'express';

export interface AuthPayload {
  sub: string;
  role?: 'user' | 'admin';
}

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  const hdr = req.headers['authorization'] || '';
  const token = hdr.startsWith('Bearer ') ? hdr.slice(7) : null;
  if (!token) return res.status(401).json({ error: 'Unauthorized' });

  try {
    const secret = process.env.JWT_SECRET || 'test_secret_change_me';
    const payload = jwt.verify(token, secret) as AuthPayload;
    (req as any).user = payload;
    next();
  } catch {
    return res.status(401).json({ error: 'Unauthorized' });
  }
}

export function requireRole(role: 'admin' | 'user') {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = (req as any).user as AuthPayload | undefined;
    if (!user) return res.status(401).json({ error: 'Unauthorized' });
    if (role === 'admin' && user.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });
    return next();
  };
}

/* backend/middleware/__tests__/auth.test.ts */
import express from 'express';
import request from 'supertest';
import jwt from 'jsonwebtoken';
import { requireAuth, requireRole } from '@/backend/middleware/auth';

describe('Auth middleware', () => {
  const secret = 'unit_test_secret';
  const app = express();
  app.get('/private', requireAuth, (req, res) => res.json({ ok: true }));
  app.get('/admin', requireAuth, requireRole('admin'), (req, res) => res.json({ ok: 'admin' }));

  test('401 on missing token', async () => {
    const res = await request(app).get('/private');
    expect(res.status).toBe(401);
    expect(res.body).toEqual({ error: 'Unauthorized' });
  });

  test('200 with valid token', async () => {
    const token = jwt.sign({ sub: 'u1', role: 'user' }, secret);
    process.env.JWT_SECRET = secret;
    const res = await request(app).get('/private').set('Authorization', `Bearer ${token}`);
    expect(res.status).toBe(200);
    expect(res.body).toEqual({ ok: true });
  });

  test('403 for non-admin on admin route', async () => {
    const token = jwt.sign({ sub: 'u1', role: 'user' }, secret);
    process.env.JWT_SECRET = secret;
    const res = await request(app).get('/admin').set('Authorization', `Bearer ${token}`);
    expect(res.status).toBe(403);
    expect(res.body).toEqual({ error: 'Forbidden' });
  });
});

ts



Express app (for API tests)

File: backend/app.ts
import express from 'express';
import bodyParser from 'body-parser';

export function createApp() {
  const app = express();
  app.use(bodyParser.json());

  app.get('/health', (_req, res) => {
    res.json({
      name: 'backend',
      status: 'ok',
      version: '1.0',
      now: 'redacted', // stable for snapshot
    });
  });

  app.post('/echo', (req, res) => {
    res.json({ youSent: req.body, received: true });
  });

  return app;
}

ts



HTTP API e2e with supertest + snapshot

File: backend/tests/api/app.e2e.test.ts
import request from 'supertest';
import { createApp } from '@/backend/app';

describe('API e2e', () => {
  const app = createApp();

  test('GET /health returns stable shape (snapshot)', async () => {
    const res = await request(app).get('/health');
    res.body.now = 'redacted';
    expect(res.status).toBe(200);
    expect(res.body).toMatchInlineSnapshot(`
      {
        "name": "backend",
        "now": "redacted",
        "status": "ok",
        "version": "1.0",
      }
    `);
  });

  test('POST /echo echoes body', async () => {
    const payload = { a: 1, b: 'two' };
    const res = await request(app).post('/echo').send(payload);
    expect(res.status).toBe(200);
    expect(res.body).toEqual({ youSent: payload, received: true });
  });
});

ts



Contract test example (schema-based with zod) using mocked HTTP via nock

File: backend/tests/contract/third-party.contract.test.ts
import https from 'https';
import nock from 'nock';
import { z } from 'zod';
import { mockJson } from '@/backend/tests/helpers/httpMock';

function fetchJson(url: string): Promise<any> {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => {
      const chunks: Buffer[] = [];
      res.on('data', (c) => chunks.push(c));
      res.on('end', () => {
        try {
          const body = JSON.parse(Buffer.concat(chunks).toString('utf8'));
          resolve({ status: res.statusCode, body });
        } catch (e) {
          reject(e);
        }
      });
    }).on('error', reject);
  });
}

const ProfileSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  displayName: z.string(),
  createdAt: z.string(), // iso date
});

describe('Third-party API contract', () => {
  const base = 'https://api.partner.example';

  afterEach(() => nock.cleanAll());

  test('profile schema remains compatible', async () => {
    mockJson(base, '/v1/profile/123', 'get', 200, {
      id: '123',
      email: 'test@example.com',
      displayName: 'Test User',
      createdAt: '2024-01-01T00:00:00.000Z',
      plan: 'pro',
    });

    const { status, body } = await fetchJson(`${base}/v1/profile/123`);
    expect(status).toBe(200);

    const parsed = ProfileSchema.parse(body);
    expect({ id: parsed.id, email: parsed.email, displayName: parsed.displayName }).toMatchInlineSnapshot(`
      {
        "displayName": "Test User",
        "email": "test@example.com",
        "id": "123",
      }
    `);
  });
});

ts



Timers and time-sensitive logic example

File: backend/tests/unit/timers.example.test.ts
describe('Timers example', () => {
  test('delays callback', () => {
    jest.useFakeTimers({ legacyFakeTimers: false });
    const cb = jest.fn();

    setTimeout(cb, 5000);
    jest.advanceTimersByTime(4999);
    expect(cb).not.toHaveBeenCalled();

    jest.advanceTimersByTime(1);
    expect(cb).toHaveBeenCalledTimes(1);

    jest.useRealTimers();
  });
});

ts


ORM adapters (Sequelize, Prisma, Mongoose) and how to swap
Sequelize repository example (implementing UserRepository)

File: backend/models/repos/user.repo.sequelize.ts
import type { UserRepository, User } from '@/backend/services/user.service';
import { User as UserModel } from '@/backend/models/User'; // adjust to your actual Sequelize model export

export const sequelizeUserRepo: UserRepository = {
  async findByEmail(email) {
    const m = await (UserModel as any).findOne({ where: { email } });
    return m ? (m.toJSON() as User) : null;
  },
  async create(data) {
    const created = await (UserModel as any).create(data);
    return created.toJSON() as User;
  },
};



In-memory DB option with SQLite for fast integration runs (Sequelize)
Files:
backend/tests/helpers/sequelize-inmemory.ts
backend/tests/integration/user.repo.sqlite.test.ts
/* backend/tests/helpers/sequelize-inmemory.ts */
import { Sequelize, DataTypes, Model } from 'sequelize';

export function makeInMemorySequelize() {
  const sequelize = new Sequelize('sqlite::memory:', { logging: false });

  class User extends Model {}
  User.init(
    {
      id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },
      email: { type: DataTypes.STRING, unique: true, allowNull: false },
      password_hash: { type: DataTypes.STRING, allowNull: false },
      created_at: { type: DataTypes.DATE, defaultValue: DataTypes.NOW },
    },
    { sequelize, modelName: 'User', tableName: 'users', timestamps: false }
  );

  return { sequelize, User };
}

/* backend/tests/integration/user.repo.sqlite.test.ts */
import { makeInMemorySequelize } from '@/backend/tests/helpers/sequelize-inmemory';
import type { UserRepository, User } from '@/backend/services/user.service';

describe('Sequelize repo on sqlite::memory:', () => {
  test('create and findByEmail', async () => {
    const { sequelize, User } = makeInMemorySequelize();
    await sequelize.sync({ force: true });

    const repo: UserRepository = {
      async findByEmail(email: string) {
        const m = await (User as any).findOne({ where: { email } });
        return m ? (m.toJSON() as User) : null;
      },
      async create(data) {
        const created = await (User as any).create(data);
        return created.toJSON() as User;
      },
    };

    const created = await repo.create({ email: 'mem@example.com', password_hash: 'h' });
    expect(created.id).toBeGreaterThan(0);

    const found = await repo.findByEmail('mem@example.com');
    expect(found?.email).toBe('mem@example.com');

    await sequelize.close();
  });
});

ts



Note: Install sqlite3 as a dev dependency if you use this path: npm i -D sqlite3

NPM scripts (backend/package.json)
File (excerpt): backend/package.json
{
  "scripts": {
    "test": "jest -c jest.config.js --selectProjects backend",
    "test:watch": "jest -c jest.config.js --watch --selectProjects backend",
    "test:changed": "jest -c jest.config.js --selectProjects backend --onlyChanged",
    "test:unit": "jest -c jest.config.js --selectProjects backend --testPathPattern='__tests__|tests/unit|services/__tests__|utils/__tests__|middleware/__tests__' --runInBand",
    "test:api": "jest -c jest.config.js --selectProjects backend --testPathPattern='tests/api' --runInBand",
    "test:contract": "jest -c jest.config.js --selectProjects backend --testPathPattern='tests/contract' --runInBand",
    "test:coverage": "COVERAGE=1 jest -c jest.config.js --selectProjects backend --coverage",
    "test:containers": "JEST_INTEGRATION_MODE=testcontainers jest -c jest.config.js --selectProjects backend --testPathPattern='tests/api|tests/contract' --runInBand",
    "test:shard:1of2": "jest -c jest.config.js --selectProjects backend --testPathPattern='.*(A|B|C|D|E|F|G|H).*'",
    "test:shard:2of2": "jest -c jest.config.js --selectProjects backend --testPathPattern='.*(I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z).*'",
    "lint": "eslint . --ext .ts,.js",
    "typecheck": "tsc -p tsconfig.testing.json --noEmit"
  },
  "devDependencies": {
    "@types/jest": "^29.5.12",
    "jest": "^29.7.0",
    "ts-jest": "^29.2.5",
    "typescript": "^5.5.4",
    "supertest": "^6.3.3",
    "nock": "^13.5.4",
    "@faker-js/faker": "^8.4.1",
    "testcontainers": "^10.10.4",
    "jest-junit": "^16.0.0",
    "jest-watch-typeahead": "^2.2.2",
    "dotenv": "^16.4.5",
    "sqlite3": "^5.1.7",
    "zod": "^3.23.8"
  }
}

json



Optional root scripts to proxy into backend

File (excerpt): package.json
{
  "scripts": {
    "test:backend": "npm --prefix ./backend run test",
    "test:backend:containers": "npm --prefix ./backend run test:containers",
    "test:backend:coverage": "npm --prefix ./backend run test:coverage"
  }
}

json


GitHub Actions CI workflow
File: .github/workflows/test.yml
name: Backend Tests

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  backend-tests:
    name: backend-${{ matrix.target }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        target: [ unit, api, contract, coverage ]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install deps (backend)
        working-directory: backend
        run: npm ci

      - name: Cache Jest
        uses: actions/cache@v4
        with:
          path: |
            backend/.jest-cache
          key: ${{ runner.os }}-jest-${{ hashFiles('backend/jest.config.js') }}

      - name: Lint
        if: matrix.target == 'unit'
        run: npm --prefix backend run lint

      - name: Typecheck
        if: matrix.target == 'unit'
        run: npm --prefix backend run typecheck

      - name: Run unit tests
        if: matrix.target == 'unit'
        run: npm --prefix backend run test:unit

      - name: Run API tests (supertest; no containers)
        if: matrix.target == 'api'
        run: npm --prefix backend run test:api

      - name: Run contract tests
        if: matrix.target == 'contract'
        run: npm --prefix backend run test:contract

      - name: Run coverage (all)
        if: matrix.target == 'coverage'
        run: npm --prefix backend run test:coverage

      - name: Upload coverage to Codecov
        if: matrix.target == 'coverage'
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: backend/coverage
          flags: backend
          fail_ci_if_error: true

  backend-integration-containers:
    name: backend-integration-containers
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install deps (backend)
        working-directory: backend
        run: npm ci

      - name: Integration tests with Testcontainers
        env:
          JEST_INTEGRATION_MODE: testcontainers
          DOCKER_HOST: unix:///var/run/docker.sock
          TESTCONTAINERS_RYUK_DISABLED: 'true'
        run: npm --prefix backend run test:containers

      - name: Archive JUnit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: junit-backend
          path: backend/reports/junit.xml

yaml



Troubleshooting notes
ESM with ts-jest: Use backend/jest.config.esm.js and set "type": "module" in package.json. Map '.js' suffixes via moduleNameMapper for Jest ESM imports.
TextEncoder/TextDecoder errors: Polyfilled in backend/jest.setup.ts.
fetch/undici: nock does not intercept undici fetch. Prefer axios/http/https for mocked interactions or use MSW Node.
OpenSSL 3 with older deps: Upgrade deps or as a last resort set NODE_OPTIONS=--openssl-legacy-provider (not recommended long term).
Prisma migrations in CI: If using Prisma, run prisma migrate deploy in globalSetup or a pre-test CI step targeting the Testcontainers DB.
Port collisions: Use supertest with in-memory app (do not call listen()).
Missing tsconfig.json root: Adjust backend/tsconfig.testing.json "extends" to "./tsconfig.json" and ensure one exists in backend/.
README slice: local runs, integration modes, debugging
File: backend/README.test.md
# Backend Testing Guide

## Quick start
- Unit tests (fast):
  npm run test:unit

- Watch mode:
  npm run test:watch

- Changed files:
  npm run test:changed

- API e2e (in-memory app via supertest):
  npm run test:api

- Contract tests (HTTP mocked):
  npm run test:contract

- Coverage:
  npm run test:coverage

## Integration modes

- Default fast mode:
  Uses mocks/in-memory with no external infrastructure. Supertest runs against the app in memory.

- True integration (Testcontainers):
  Requires Docker. Starts ephemeral Postgres, migrates and seeds.
  npm run test:containers

- Optional docker-compose services:
  docker compose -f backend/test/env/docker-compose.test.yml up -d
  Set DB envs to point to localhost:5433

## Determinism
- Faker:
  const faker = makeFaker(123);

- Timers:
  jest.useFakeTimers(); ... jest.useRealTimers();

## Adapting server.js
Export your Express app and only listen when run directly:
- CommonJS:
  const app = buildApp();
  if (require.main === module) app.listen(process.env.PORT || 5001);
  module.exports = app;

- ESM:
  const app = buildApp();
  if (import.meta.url === `file://${process.argv[1]}`) app.listen(process.env.PORT || 5001);
  export default app;

Or use `backend/app.ts` in tests.

## @/ alias
@/ maps to the repository root. Import backend modules like:
import { toSlug } from '@/backend/utils/slug';

md



Install required dev dependencies once inside backend

npm i -D jest ts-jest @types/jest typescript supertest nock @faker-js/faker testcontainers jest-junit jest-watch-typeahead dotenv sqlite3 zod

sh


This plan and artifacts are tailored to Node 18+, TypeScript, @/ alias mapping to repo root, Express+Sequelize codebases, with clear variants for ESM/CommonJS, in-memory vs Testcontainers integration, and CI with coverage enforcement.